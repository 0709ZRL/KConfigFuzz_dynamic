diff --git a/sys/syz-sysgen/sysgen.go b/sys/syz-sysgen/sysgen.go
index 62f36c3d..4348040d 100644
--- a/sys/syz-sysgen/sysgen.go
+++ b/sys/syz-sysgen/sysgen.go
@@ -58,6 +58,7 @@ type ExecutorData struct {
 
 var srcDir = flag.String("src", "", "path to root of syzkaller source dir")
 var outDir = flag.String("out", "", "path to out dir")
+var rsOutDir = flag.String("rs_out", "", "path to rs out dir")
 
 func main() {
 	flag.Parse()
@@ -80,6 +81,7 @@ func main() {
 			os.Exit(1)
 		}
 		osutil.MkdirAll(filepath.Join(*outDir, "sys", OS, "gen"))
+		osutil.MkdirAll(filepath.Join(*rsOutDir, OS))
 
 		var archs []string
 		for arch := range targets.List[OS] {
@@ -136,11 +138,15 @@ func main() {
 				job.Unsupported = prog.Unsupported
 
 				sysFile := filepath.Join(*outDir, "sys", OS, "gen", job.Target.Arch+".go")
+				rsFile := filepath.Join(*rsOutDir, OS, job.Target.Arch+".rs")
 				out := new(bytes.Buffer)
 				generate(job.Target, prog, consts, out)
+				rs_out := new(bytes.Buffer)
+				generate_rs(job.Target, prog, consts, rs_out)
 				rev := hash.String(out.Bytes())
 				fmt.Fprintf(out, "const revision_%v = %q\n", job.Target.Arch, rev)
 				writeSource(sysFile, out.Bytes())
+				writeSource(rsFile, rs_out.Bytes())
 
 				job.ArchData = generateExecutorSyscalls(job.Target, prog.Syscalls, rev)
 
@@ -187,6 +193,264 @@ func main() {
 	writeExecutorSyscalls(data)
 }
 
+func generate_rs(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, out io.Writer) {
+	fmt.Fprintf(out, "//! System call information of %v/%v\n", target.OS, target.Arch)
+	fmt.Fprintf(out, "//! AUTOGENERATED FILE. DO NOT EDIT.\n")
+	fmt.Fprintf(out, "use std::rc::Rc;\n")
+	fmt.Fprintf(out, "use hlang::ast::*;\n\n")
+	fmt.Fprintf(out, "pub fn syscalls() -> (Vec<Syscall>, Vec<Rc<Type>>){\n")
+	fmt.Fprintf(out, "\tlet tys = types();\n")
+	fmt.Fprintf(out, "\tlet calls = vec![\n")
+	for id, call := range prg.Syscalls {
+		generate_rs_call(target, prg, consts, out, call, id)
+	}
+	fmt.Fprintf(out, "\t];\n")
+	fmt.Fprintf(out, "\t(calls, tys)\n")
+	fmt.Fprintf(out, "}\n\n")
+
+	fmt.Fprintf(out, "fn types() -> Vec<Rc<Type>>{\n")
+	fmt.Fprintf(out, "\tvec![\n")
+	for id, ty := range prg.Types {
+		generate_rs_ty(target, prg, consts, out, ty, id)
+	}
+	fmt.Fprintf(out, "\t]\n")
+	fmt.Fprintf(out, "}\n")
+}
+
+func generate_rs_call(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, decl io.Writer, call *prog.Syscall, id int) {
+	fmt.Fprintf(decl, "\t\tSyscall::new(%v, %v, \"%v\", \"%v\", %v, ", id, call.NR, call.Name, call.CallName, call.MissingArgs)
+	fmt.Fprintf(decl, "vec![")
+
+	for _, p := range call.Args {
+		ref := deref_ret(p.Type)
+		fmt.Fprintf(decl, "Param{ name: \"%v\", ty: tys[%v].clone(), dir: %v }, ", p.Name, ref, field_dir_to_str(p))
+	}
+	fmt.Fprintf(decl, "], ")
+	if call.Ret != nil {
+		ret := deref_ret(call.Ret)
+		fmt.Fprintf(decl, "Some(tys[%v].clone()), ", uint32(ret))
+	} else {
+		fmt.Fprintf(decl, "None,")
+	}
+	attr := call.Attrs
+	fmt.Fprintf(decl, "SyscallAttr{ disable: %v, timeout: %v, prog_tmout: %v, ignore_ret: %v, brk_ret: %v}", attr.Disabled, attr.Timeout, attr.ProgTimeout, attr.IgnoreReturn, attr.BreaksReturns)
+	fmt.Fprintf(decl, "),\n")
+}
+func dir_to_str(p prog.Dir) string {
+	if p == prog.DirIn {
+		return "Some(Dir::In)"
+	} else if p == prog.DirOut {
+		return "Some(Dir::Out)"
+	} else {
+		return "Some(Dir::InOut)"
+	}
+}
+
+func field_dir_to_str(f prog.Field) string {
+	if f.HasDirection {
+		return dir_to_str(f.Direction)
+	} else {
+		return "None"
+	}
+}
+
+func deref_ret(ty prog.Type) uint32 {
+	if ref, ok := ty.(prog.Ref); ok {
+		return uint32(ref)
+	} else {
+		panic("Expect ref type, found " + ty.Name())
+	}
+}
+
+func generate_rs_ty(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, out io.Writer, ty prog.Type, id int) {
+	resourceMap := make(map[string]*prog.ResourceDesc)
+	for _, res := range prg.Resources {
+		resourceMap[res.Name] = res
+	}
+
+	// id, name, size, align, optional, varlen, kind
+	switch aty := ty.(type) {
+	case *prog.IntType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Int{int_fmt:IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.IntTypeCommon.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		if aty.Kind == prog.IntRange {
+			fmt.Fprintf(out, "range: Some((%v, %v)), ", aty.RangeBegin, aty.RangeEnd)
+		} else {
+			fmt.Fprintf(out, "range: None, ")
+		}
+		fmt.Fprintf(out, "align: %v}", aty.Align)
+		fmt.Fprintf(out, "),\n")
+	case *prog.LenType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_len(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "%v, ", aty.BitSize)
+		fmt.Fprintf(out, "%v, ", aty.Offset)
+		fmt.Fprintf(out, "vec![")
+		for _, path := range aty.Path {
+			fmt.Fprintf(out, "%v, ", path)
+		}
+		fmt.Fprintf(out, "]")
+		fmt.Fprintf(out, ")")
+		fmt.Fprintf(out, "),\n")
+	case *prog.CsumType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_csum(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "%v, ", csum_str(aty.Kind))
+		if aty.Buf != "" {
+			fmt.Fprintf(out, "Some(%+q), ", aty.Buf)
+		} else {
+			fmt.Fprintf(out, "None, ")
+		}
+		fmt.Fprintf(out, "%v)", aty.Protocol)
+		fmt.Fprintf(out, "),\n")
+	case *prog.BufferType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::new_buffer(")
+		if aty.Kind == prog.BufferBlobRand {
+			fmt.Fprintf(out, "BufferKind::BlobRand, ")
+		} else if aty.Kind == prog.BufferBlobRange {
+			fmt.Fprintf(out, "BufferKind::BlobRange(%v, %v), ", aty.RangeBegin, aty.RangeEnd)
+		} else if aty.Kind == prog.BufferString {
+			fmt.Fprintf(out, "BufferKind::new_str(vec![")
+			for _, v := range aty.Values {
+				fmt.Fprintf(out, "%+q, ", v)
+			}
+			fmt.Fprintf(out, "], ")
+			fmt.Fprintf(out, "%v), ", aty.NoZ)
+		} else if aty.Kind == prog.BufferFilename {
+			fmt.Fprintf(out, "BufferKind::new_fname(vec![")
+			for _, v := range aty.Values {
+				fmt.Fprintf(out, "%+q, ", v)
+			}
+			fmt.Fprintf(out, "], ")
+			fmt.Fprintf(out, "%v),", aty.NoZ)
+		} else {
+			fmt.Fprintf(out, "BufferKind::Text(")
+			if aty.Text == prog.TextTarget {
+				fmt.Fprintf(out, "TextKind::Target),")
+			} else if aty.Text == prog.TextX86Real {
+				fmt.Fprintf(out, "TextKind::X86),")
+			} else if aty.Text == prog.TextX86bit16 {
+				fmt.Fprintf(out, "TextKind::X86bit16),")
+			} else if aty.Text == prog.TextX86bit32 {
+				fmt.Fprintf(out, "TextKind::X86bit32),")
+			} else if aty.Text == prog.TextX86bit64 {
+				fmt.Fprintf(out, "TextKind::X86bit64),")
+			} else if aty.Text == prog.TextArm64 {
+				fmt.Fprintf(out, "TextKind::Arm64),")
+			}
+		}
+		fmt.Fprintf(out, "%v)", aty.SubKind)
+
+		fmt.Fprintf(out, "),\n")
+
+	case *prog.FlagsType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::new_flags(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "vec![")
+		for _, val := range aty.Vals {
+			fmt.Fprintf(out, "%v, ", val)
+		}
+		fmt.Fprintf(out, "], ")
+		fmt.Fprintf(out, "%v)", aty.BitMask)
+		fmt.Fprintf(out, "),\n")
+
+	case *prog.ConstType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::Const{int_fmt: IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "val: %v, ", aty.Val)
+		fmt.Fprintf(out, "pad: %v}", aty.IsPad)
+		fmt.Fprintf(out, "),\n")
+
+	case *prog.ProcType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Prog{int_fmt: IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "start: %v, per_proc: %v}", aty.ValuesStart, aty.ValuesPerProc)
+		fmt.Fprintf(out, "),\n")
+	case *prog.VmaType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Vma{begin: %v, end: %v}", aty.RangeBegin, aty.RangeEnd)
+		fmt.Fprintf(out, "),\n")
+	case *prog.ResourceType:
+		desc := resourceMap[aty.TypeName]
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Res{fmt: %v, desc: ResDesc::new(\"%v\", vec![", binfmt_str(aty.ArgFormat), desc.Name)
+		for _, kind := range desc.Kind {
+			fmt.Fprintf(out, "\"%v\", ", kind)
+		}
+		fmt.Fprintf(out, "], vec![")
+		for _, val := range desc.Values {
+			fmt.Fprintf(out, "%v, ", val)
+		}
+		fmt.Fprintf(out, "])}")
+
+		fmt.Fprintf(out, "),\n")
+	case *prog.PtrType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Ptr{dir: %v, elem: TypeRef::Id(%v)}", dir_to_str(aty.ElemDir), deref_ret(aty.Elem))
+		fmt.Fprintf(out, "),\n")
+	case *prog.StructType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_struct(%v, vec![", aty.AlignAttr)
+		for _, f := range aty.Fields {
+			fmt.Fprintf(out, "Field{ name: \"%v\", ty: TypeRef::Id(%v), dir: %v }, ", f.Name, deref_ret(f.Type), field_dir_to_str(f))
+		}
+		fmt.Fprintf(out, "])")
+		fmt.Fprintf(out, "),\n")
+	case *prog.UnionType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_union(vec![")
+		for _, f := range aty.Fields {
+			fmt.Fprintf(out, "Field{ name: \"%v\", ty: TypeRef::Id(%v), dir: %v }, ", f.Name, deref_ret(f.Type), field_dir_to_str(f))
+		}
+		fmt.Fprintf(out, "])")
+		fmt.Fprintf(out, "),\n")
+	case *prog.ArrayType:
+		fmt.Fprintf(out, "\t\tType::new(%d, \"%v\", %v, %v, %v, %v, ", id, aty.TypeName, aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Array{elem: %v, range:", deref_ret(aty.Elem))
+		if aty.Kind == prog.ArrayRangeLen {
+			fmt.Fprintf(out, "Some((%v, %v))}", aty.RangeBegin, aty.RangeEnd)
+		} else {
+			fmt.Fprintf(out, "None}")
+		}
+		fmt.Fprintf(out, "),\n")
+	default:
+		panic("Unhandled type")
+	}
+
+}
+
+func csum_str(k prog.CsumKind) string {
+	if k == prog.CsumInet {
+		return "CsumKind::Inet"
+	} else {
+		return "Csumkind::Pseudo"
+	}
+}
+
+func binfmt_str(f prog.BinaryFormat) string {
+	if f == prog.FormatNative {
+		return "BinFmt::Native"
+	} else if f == prog.FormatBigEndian {
+		return "BinFmt::BigEndian"
+	} else if f == prog.FormatStrDec {
+		return "BinFmt::StrDec"
+	} else if f == prog.FormatStrHex {
+		return "BinFmt::StrHex"
+	} else {
+		return "BinFmt::StrOct"
+	}
+}
+
 func generate(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, out io.Writer) {
 	tag := fmt.Sprintf("syz_target,syz_os_%v,syz_arch_%v", target.OS, target.Arch)
 	if target.VMArch != "" {
