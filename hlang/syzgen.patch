diff --git a/sys/syz-sysgen/sysgen.go b/sys/syz-sysgen/sysgen.go
index 62f36c3d..fb438b3a 100644
--- a/sys/syz-sysgen/sysgen.go
+++ b/sys/syz-sysgen/sysgen.go
@@ -13,6 +13,7 @@ import (
 	"path/filepath"
 	"reflect"
 	"sort"
+	"strconv"
 	"strings"
 	"sync"
 	"text/template"
@@ -58,6 +59,7 @@ type ExecutorData struct {
 
 var srcDir = flag.String("src", "", "path to root of syzkaller source dir")
 var outDir = flag.String("out", "", "path to out dir")
+var rsOutDir = flag.String("rs_out", "", "path to rs out dir")
 
 func main() {
 	flag.Parse()
@@ -80,6 +82,7 @@ func main() {
 			os.Exit(1)
 		}
 		osutil.MkdirAll(filepath.Join(*outDir, "sys", OS, "gen"))
+		osutil.MkdirAll(filepath.Join(*rsOutDir, OS))
 
 		var archs []string
 		for arch := range targets.List[OS] {
@@ -136,11 +139,20 @@ func main() {
 				job.Unsupported = prog.Unsupported
 
 				sysFile := filepath.Join(*outDir, "sys", OS, "gen", job.Target.Arch+".go")
+				rs_file_name := job.Target.Arch + ".rs"
+				if rs_file_name[0] >= '0' && rs_file_name[0] <= '9' {
+					rs_file_name = "_" + rs_file_name
+				}
+				rsFile := filepath.Join(*rsOutDir, OS, rs_file_name)
 				out := new(bytes.Buffer)
 				generate(job.Target, prog, consts, out)
+				rs_out := new(bytes.Buffer)
+				generate_rs(job.Target, prog, consts, rs_out)
 				rev := hash.String(out.Bytes())
 				fmt.Fprintf(out, "const revision_%v = %q\n", job.Target.Arch, rev)
+				fmt.Fprintf(rs_out, "\npub static REVISION : &str = %q;\n", rev)
 				writeSource(sysFile, out.Bytes())
+				writeSource(rsFile, rs_out.Bytes())
 
 				job.ArchData = generateExecutorSyscalls(job.Target, prog.Syscalls, rev)
 
@@ -187,6 +199,315 @@ func main() {
 	writeExecutorSyscalls(data)
 }
 
+func generate_rs(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, out io.Writer) {
+	fmt.Fprintf(out, "//! System call information of %v/%v\n", target.OS, target.Arch)
+	fmt.Fprintf(out, "//! AUTOGENERATED FILE. DO NOT EDIT.\n")
+	fmt.Fprintf(out, "use std::rc::Rc;\n")
+	fmt.Fprintf(out, "use hlang::ast::*;\n\n")
+
+	var fn_names []string
+	crt_len := 64
+	calls := prg.Syscalls
+	for i := 0; len(calls) != 0; i += 1 {
+		if len(calls) < crt_len {
+			crt_len = len(calls)
+		}
+		fn_name := generate_syscalls(target, prg, consts, out, calls[0:crt_len], i*64, i)
+		calls = calls[crt_len:]
+		fn_names = append(fn_names, fn_name)
+	}
+
+	fmt.Fprintf(out, "pub fn syscalls() -> (Vec<Syscall>, Vec<Rc<Type>>){\n")
+	fmt.Fprintf(out, "\tlet tys = types();\n")
+	fmt.Fprintf(out, "\tlet mut calls = Vec::new();\n")
+	for _, fn_name := range fn_names {
+		fmt.Fprintf(out, "\t%v(&mut calls, &tys[..]);\n", fn_name)
+	}
+	fmt.Fprintf(out, "\t(calls, tys)\n")
+	fmt.Fprintf(out, "}\n\n")
+
+	fn_names = []string{}
+	crt_len = 64
+	types := prg.Types
+	for i := 0; len(types) != 0; i += 1 {
+		if len(types) < crt_len {
+			crt_len = len(types)
+		}
+		fn_name := generate_rs_tys(target, prg, consts, out, types[0:crt_len], i*64, i)
+		types = types[crt_len:]
+		fn_names = append(fn_names, fn_name)
+	}
+
+	fmt.Fprintf(out, "fn types() -> Vec<Rc<Type>>{\n")
+	fmt.Fprintf(out, "\tlet mut tys = Vec::new();\n")
+	for _, fn_name := range fn_names {
+		fmt.Fprintf(out, "\t%v(&mut tys);\n", fn_name)
+	}
+	fmt.Fprintf(out, "\ttys\n")
+	fmt.Fprintf(out, "}\n")
+}
+
+func generate_syscalls(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, decl io.Writer, calls []*prog.Syscall, base_id int, id int) string {
+	fn_name := "syscalls_" + strconv.Itoa(id)
+	fmt.Fprintf(decl, "fn syscalls_%v(calls: &mut Vec<Syscall>, tys: &[Rc<Type>]){\n", id)
+	for i, call := range calls {
+		fmt.Fprintf(decl, "\tcalls.push(")
+		generate_rs_call(target, prg, consts, decl, call, base_id+i)
+		fmt.Fprintf(decl, ");\n")
+	}
+	fmt.Fprintf(decl, "}\n")
+	return fn_name
+}
+
+func generate_rs_call(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, decl io.Writer, call *prog.Syscall, id int) {
+	fmt.Fprintf(decl, "Syscall::new(%v, %v, \"%v\", \"%v\", %v, ", id, call.NR, call.Name, call.CallName, call.MissingArgs)
+	fmt.Fprintf(decl, "vec![")
+
+	for _, p := range call.Args {
+		ref := deref_ret(p.Type)
+		fmt.Fprintf(decl, "Param::new(\"%v\", tys[%v].clone(), %v), ", p.Name, ref, field_dir_to_str(p))
+	}
+	fmt.Fprintf(decl, "], ")
+	if call.Ret != nil {
+		ret := deref_ret(call.Ret)
+		fmt.Fprintf(decl, "Some(tys[%v].clone()), ", uint32(ret))
+	} else {
+		fmt.Fprintf(decl, "None,")
+	}
+	attr := call.Attrs
+	fmt.Fprintf(decl, "SyscallAttr{ disable: %v, timeout: %v, prog_tmout: %v, ignore_ret: %v, brk_ret: %v}", attr.Disabled, attr.Timeout, attr.ProgTimeout, attr.IgnoreReturn, attr.BreaksReturns)
+	fmt.Fprintf(decl, ")")
+}
+
+func dir_to_str(p prog.Dir) string {
+	if p == prog.DirIn {
+		return "Dir::In"
+	} else if p == prog.DirOut {
+		return "Dir::Out"
+	} else {
+		return "Dir::InOut"
+	}
+}
+
+func field_dir_to_str(f prog.Field) string {
+	if f.HasDirection {
+		return "Some(" + dir_to_str(f.Direction) + ")"
+	} else {
+		return "None"
+	}
+}
+
+func deref_ret(ty prog.Type) uint32 {
+	if ref, ok := ty.(prog.Ref); ok {
+		return uint32(ref)
+	} else {
+		panic("Expect ref type, found " + ty.Name())
+	}
+}
+
+func generate_rs_tys(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, decl io.Writer, tys []prog.Type, base_id int, id int) string {
+	fn_name := "types_" + strconv.Itoa(id)
+	fmt.Fprintf(decl, "fn types_%v(tys: &mut Vec<Rc<Type>>){\n", id)
+	for i, ty := range tys {
+		fmt.Fprintf(decl, "\ttys.push(")
+		generate_rs_ty(target, prg, consts, decl, ty, base_id+i)
+		fmt.Fprintf(decl, ");\n")
+	}
+	fmt.Fprintf(decl, "}\n")
+	return fn_name
+}
+
+func generate_rs_ty(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, src io.Writer, ty prog.Type, id int) {
+	resourceMap := make(map[string]*prog.ResourceDesc)
+	for _, res := range prg.Resources {
+		resourceMap[res.Name] = res
+	}
+
+	out := new(bytes.Buffer)
+	// id, name, size, align, optional, varlen, kind
+	switch aty := ty.(type) {
+	case *prog.IntType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Int{int_fmt:IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.IntTypeCommon.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		if aty.Kind == prog.IntRange {
+			fmt.Fprintf(out, "range: Some((%v, %v)), ", aty.RangeBegin, aty.RangeEnd)
+		} else {
+			fmt.Fprintf(out, "range: None, ")
+		}
+		fmt.Fprintf(out, "align: %v}", aty.Align)
+		fmt.Fprintf(out, ")")
+	case *prog.LenType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_len(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "%v, ", aty.BitSize)
+		fmt.Fprintf(out, "%v, ", aty.Offset)
+		fmt.Fprintf(out, "vec![")
+		for _, path := range aty.Path {
+			fmt.Fprintf(out, "%v, ", strconv.QuoteToASCII(path))
+		}
+		fmt.Fprintf(out, "]")
+		fmt.Fprintf(out, ")")
+		fmt.Fprintf(out, ")")
+	case *prog.CsumType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_csum(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "%v, ", csum_str(aty.Kind))
+		if aty.Buf != "" {
+			fmt.Fprintf(out, "Some(r#%+q#), ", aty.Buf)
+		} else {
+			fmt.Fprintf(out, "None, ")
+		}
+		fmt.Fprintf(out, "%v)", aty.Protocol)
+		fmt.Fprintf(out, ")")
+	case *prog.BufferType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::new_buffer(")
+		if aty.Kind == prog.BufferBlobRand {
+			fmt.Fprintf(out, "BufferKind::BlobRand, ")
+		} else if aty.Kind == prog.BufferBlobRange {
+			fmt.Fprintf(out, "BufferKind::BlobRange(%v, %v), ", aty.RangeBegin, aty.RangeEnd)
+		} else if aty.Kind == prog.BufferString {
+			fmt.Fprintf(out, "BufferKind::new_str(vec![")
+			for _, v := range aty.Values {
+				fmt.Fprintf(out, "br#%+q#, ", v)
+			}
+			fmt.Fprintf(out, "], ")
+			fmt.Fprintf(out, "%v), ", aty.NoZ)
+		} else if aty.Kind == prog.BufferFilename {
+			fmt.Fprintf(out, "BufferKind::new_fname(vec![")
+			for _, v := range aty.Values {
+				fmt.Fprintf(out, "%v, ", strconv.QuoteToASCII(v))
+			}
+			fmt.Fprintf(out, "], ")
+			fmt.Fprintf(out, "%v),", aty.NoZ)
+		} else {
+			fmt.Fprintf(out, "BufferKind::Text(")
+			if aty.Text == prog.TextTarget {
+				fmt.Fprintf(out, "TextKind::Target),")
+			} else if aty.Text == prog.TextX86Real {
+				fmt.Fprintf(out, "TextKind::X86Real),")
+			} else if aty.Text == prog.TextX86bit16 {
+				fmt.Fprintf(out, "TextKind::X86bit16),")
+			} else if aty.Text == prog.TextX86bit32 {
+				fmt.Fprintf(out, "TextKind::X86bit32),")
+			} else if aty.Text == prog.TextX86bit64 {
+				fmt.Fprintf(out, "TextKind::X86bit64),")
+			} else if aty.Text == prog.TextArm64 {
+				fmt.Fprintf(out, "TextKind::Arm64),")
+			}
+		}
+		fmt.Fprintf(out, "%v)", strconv.QuoteToASCII(aty.SubKind))
+
+		fmt.Fprintf(out, ")")
+
+	case *prog.FlagsType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::new_flags(IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "vec![")
+		for _, val := range aty.Vals {
+			fmt.Fprintf(out, "%v, ", val)
+		}
+		fmt.Fprintf(out, "], ")
+		fmt.Fprintf(out, "%v)", aty.BitMask)
+		fmt.Fprintf(out, ")")
+
+	case *prog.ConstType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+
+		fmt.Fprintf(out, "TypeKind::Const{int_fmt: IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "val: %v, ", aty.Val)
+		fmt.Fprintf(out, "pad: %v}", aty.IsPad)
+		fmt.Fprintf(out, ")")
+
+	case *prog.ProcType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Proc{int_fmt: IntFmt{fmt:%v, bitfield_off: %v, bitfield_len: %v, bitfield_unit: %v, bitfield_unit_off: %v}, ",
+			binfmt_str(aty.ArgFormat), aty.BitfieldOff, aty.BitfieldLen, aty.BitfieldUnit, aty.BitfieldUnitOff)
+		fmt.Fprintf(out, "start: %v, per_proc: %v}", aty.ValuesStart, aty.ValuesPerProc)
+		fmt.Fprintf(out, ")")
+	case *prog.VmaType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Vma{begin: %v, end: %v}", aty.RangeBegin, aty.RangeEnd)
+		fmt.Fprintf(out, ")")
+	case *prog.ResourceType:
+		desc := resourceMap[aty.TypeName]
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Res{fmt: %v, desc: ResDesc::new(\"%v\", vec![", binfmt_str(aty.ArgFormat), desc.Name)
+		for _, kind := range desc.Kind {
+			fmt.Fprintf(out, "\"%v\", ", kind)
+		}
+		fmt.Fprintf(out, "], vec![")
+		for _, val := range desc.Values {
+			fmt.Fprintf(out, "%v, ", val)
+		}
+		fmt.Fprintf(out, "])}")
+
+		fmt.Fprintf(out, ")")
+	case *prog.PtrType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Ptr{dir: %v, elem: TypeRef::Id(%v)}", dir_to_str(aty.ElemDir), deref_ret(aty.Elem))
+		fmt.Fprintf(out, ")")
+	case *prog.StructType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_struct(%v, vec![", aty.AlignAttr)
+		for _, f := range aty.Fields {
+			fmt.Fprintf(out, "Field{ name: String::into_boxed_str(%v.to_string()), ty: TypeRef::Id(%v), dir: %v }, ", strconv.QuoteToASCII(f.Name), deref_ret(f.Type), field_dir_to_str(f))
+		}
+		fmt.Fprintf(out, "])")
+		fmt.Fprintf(out, ")")
+	case *prog.UnionType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::new_union(vec![")
+		for _, f := range aty.Fields {
+			fmt.Fprintf(out, "Field{ name: String::into_boxed_str(%v.to_string()), ty: TypeRef::Id(%v), dir: %v }, ", strconv.QuoteToASCII(f.Name), deref_ret(f.Type), field_dir_to_str(f))
+		}
+		fmt.Fprintf(out, "])")
+		fmt.Fprintf(out, ")")
+	case *prog.ArrayType:
+		fmt.Fprintf(out, "Type::new(%d, %v, %v, %v, %v, %v, ", id, strconv.QuoteToASCII(aty.TypeName), aty.TypeSize, aty.TypeAlign, aty.IsOptional, aty.IsVarlen)
+		fmt.Fprintf(out, "TypeKind::Array{elem: TypeRef::Id(%v), range:", deref_ret(aty.Elem))
+		if aty.Kind == prog.ArrayRangeLen {
+			fmt.Fprintf(out, "Some((%v, %v))}", aty.RangeBegin, aty.RangeEnd)
+		} else {
+			fmt.Fprintf(out, "None}")
+		}
+		fmt.Fprintf(out, ")")
+	default:
+		panic("Unhandled type")
+	}
+	fmt.Fprintf(src, "Rc::new(%v)", string(out.Bytes()))
+
+}
+
+func csum_str(k prog.CsumKind) string {
+	if k == prog.CsumInet {
+		return "CsumKind::Inet"
+	} else {
+		return "CsumKind::Pseudo"
+	}
+}
+
+func binfmt_str(f prog.BinaryFormat) string {
+	if f == prog.FormatNative {
+		return "BinFmt::Native"
+	} else if f == prog.FormatBigEndian {
+		return "BinFmt::BigEndian"
+	} else if f == prog.FormatStrDec {
+		return "BinFmt::StrDec"
+	} else if f == prog.FormatStrHex {
+		return "BinFmt::StrHex"
+	} else {
+		return "BinFmt::StrOct"
+	}
+}
+
 func generate(target *targets.Target, prg *compiler.Prog, consts map[string]uint64, out io.Writer) {
 	tag := fmt.Sprintf("syz_target,syz_os_%v,syz_arch_%v", target.OS, target.Arch)
 	if target.VMArch != "" {
