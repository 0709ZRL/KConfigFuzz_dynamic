/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _SETJMP_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const GLOBAL_TABLE_SIZE: u32 = 97;
pub const STRING_TABLE_SIZE: u32 = 97;
pub const STRING_LITERAL_TABLE_SIZE: u32 = 97;
pub const RESERVED_WORD_TABLE_SIZE: u32 = 97;
pub const PARAMETER_MAX: u32 = 16;
pub const LINEBUFFER_MAX: u32 = 256;
pub const LOCAL_TABLE_SIZE: u32 = 11;
pub const STRUCT_TABLE_SIZE: u32 = 11;
pub const INTERACTIVE_PROMPT_STATEMENT: &'static [u8; 8usize] = b"picoc> \0";
pub const INTERACTIVE_PROMPT_LINE: &'static [u8; 8usize] = b"     > \0";
pub const GETS_BUF_MAX: u32 = 256;
pub const FREELIST_BUCKETS: u32 = 8;
pub const SPLIT_MEM_THRESHOLD: u32 = 16;
pub const BREAKPOINT_TABLE_SIZE: u32 = 21;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type IOFILE = FILE;
pub type Picoc = Picoc_Struct;
pub const LexToken_TokenNone: LexToken = 0;
pub const LexToken_TokenComma: LexToken = 1;
pub const LexToken_TokenAssign: LexToken = 2;
pub const LexToken_TokenAddAssign: LexToken = 3;
pub const LexToken_TokenSubtractAssign: LexToken = 4;
pub const LexToken_TokenMultiplyAssign: LexToken = 5;
pub const LexToken_TokenDivideAssign: LexToken = 6;
pub const LexToken_TokenModulusAssign: LexToken = 7;
pub const LexToken_TokenShiftLeftAssign: LexToken = 8;
pub const LexToken_TokenShiftRightAssign: LexToken = 9;
pub const LexToken_TokenArithmeticAndAssign: LexToken = 10;
pub const LexToken_TokenArithmeticOrAssign: LexToken = 11;
pub const LexToken_TokenArithmeticExorAssign: LexToken = 12;
pub const LexToken_TokenQuestionMark: LexToken = 13;
pub const LexToken_TokenColon: LexToken = 14;
pub const LexToken_TokenLogicalOr: LexToken = 15;
pub const LexToken_TokenLogicalAnd: LexToken = 16;
pub const LexToken_TokenArithmeticOr: LexToken = 17;
pub const LexToken_TokenArithmeticExor: LexToken = 18;
pub const LexToken_TokenAmpersand: LexToken = 19;
pub const LexToken_TokenEqual: LexToken = 20;
pub const LexToken_TokenNotEqual: LexToken = 21;
pub const LexToken_TokenLessThan: LexToken = 22;
pub const LexToken_TokenGreaterThan: LexToken = 23;
pub const LexToken_TokenLessEqual: LexToken = 24;
pub const LexToken_TokenGreaterEqual: LexToken = 25;
pub const LexToken_TokenShiftLeft: LexToken = 26;
pub const LexToken_TokenShiftRight: LexToken = 27;
pub const LexToken_TokenPlus: LexToken = 28;
pub const LexToken_TokenMinus: LexToken = 29;
pub const LexToken_TokenAsterisk: LexToken = 30;
pub const LexToken_TokenSlash: LexToken = 31;
pub const LexToken_TokenModulus: LexToken = 32;
pub const LexToken_TokenIncrement: LexToken = 33;
pub const LexToken_TokenDecrement: LexToken = 34;
pub const LexToken_TokenUnaryNot: LexToken = 35;
pub const LexToken_TokenUnaryExor: LexToken = 36;
pub const LexToken_TokenSizeof: LexToken = 37;
pub const LexToken_TokenCast: LexToken = 38;
pub const LexToken_TokenLeftSquareBracket: LexToken = 39;
pub const LexToken_TokenRightSquareBracket: LexToken = 40;
pub const LexToken_TokenDot: LexToken = 41;
pub const LexToken_TokenArrow: LexToken = 42;
pub const LexToken_TokenOpenBracket: LexToken = 43;
pub const LexToken_TokenCloseBracket: LexToken = 44;
pub const LexToken_TokenIdentifier: LexToken = 45;
pub const LexToken_TokenIntegerConstant: LexToken = 46;
pub const LexToken_TokenFPConstant: LexToken = 47;
pub const LexToken_TokenStringConstant: LexToken = 48;
pub const LexToken_TokenCharacterConstant: LexToken = 49;
pub const LexToken_TokenSemicolon: LexToken = 50;
pub const LexToken_TokenEllipsis: LexToken = 51;
pub const LexToken_TokenLeftBrace: LexToken = 52;
pub const LexToken_TokenRightBrace: LexToken = 53;
pub const LexToken_TokenIntType: LexToken = 54;
pub const LexToken_TokenCharType: LexToken = 55;
pub const LexToken_TokenFloatType: LexToken = 56;
pub const LexToken_TokenDoubleType: LexToken = 57;
pub const LexToken_TokenVoidType: LexToken = 58;
pub const LexToken_TokenEnumType: LexToken = 59;
pub const LexToken_TokenLongType: LexToken = 60;
pub const LexToken_TokenSignedType: LexToken = 61;
pub const LexToken_TokenShortType: LexToken = 62;
pub const LexToken_TokenStaticType: LexToken = 63;
pub const LexToken_TokenAutoType: LexToken = 64;
pub const LexToken_TokenRegisterType: LexToken = 65;
pub const LexToken_TokenExternType: LexToken = 66;
pub const LexToken_TokenStructType: LexToken = 67;
pub const LexToken_TokenUnionType: LexToken = 68;
pub const LexToken_TokenUnsignedType: LexToken = 69;
pub const LexToken_TokenTypedef: LexToken = 70;
pub const LexToken_TokenContinue: LexToken = 71;
pub const LexToken_TokenDo: LexToken = 72;
pub const LexToken_TokenElse: LexToken = 73;
pub const LexToken_TokenFor: LexToken = 74;
pub const LexToken_TokenGoto: LexToken = 75;
pub const LexToken_TokenIf: LexToken = 76;
pub const LexToken_TokenWhile: LexToken = 77;
pub const LexToken_TokenBreak: LexToken = 78;
pub const LexToken_TokenSwitch: LexToken = 79;
pub const LexToken_TokenCase: LexToken = 80;
pub const LexToken_TokenDefault: LexToken = 81;
pub const LexToken_TokenReturn: LexToken = 82;
pub const LexToken_TokenHashDefine: LexToken = 83;
pub const LexToken_TokenHashInclude: LexToken = 84;
pub const LexToken_TokenHashIf: LexToken = 85;
pub const LexToken_TokenHashIfdef: LexToken = 86;
pub const LexToken_TokenHashIfndef: LexToken = 87;
pub const LexToken_TokenHashElse: LexToken = 88;
pub const LexToken_TokenHashEndif: LexToken = 89;
pub const LexToken_TokenNew: LexToken = 90;
pub const LexToken_TokenDelete: LexToken = 91;
pub const LexToken_TokenOpenMacroBracket: LexToken = 92;
pub const LexToken_TokenEOF: LexToken = 93;
pub const LexToken_TokenEndOfLine: LexToken = 94;
pub const LexToken_TokenEndOfFunction: LexToken = 95;
pub type LexToken = u32;
#[repr(C)]
#[derive(Debug)]
pub struct AllocNode {
    pub Size: ::std::os::raw::c_uint,
    pub NextFree: *mut AllocNode,
}
#[test]
fn bindgen_test_layout_AllocNode() {
    assert_eq!(
        ::std::mem::size_of::<AllocNode>(),
        16usize,
        concat!("Size of: ", stringify!(AllocNode))
    );
    assert_eq!(
        ::std::mem::align_of::<AllocNode>(),
        8usize,
        concat!("Alignment of ", stringify!(AllocNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AllocNode>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocNode),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AllocNode>())).NextFree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AllocNode),
            "::",
            stringify!(NextFree)
        )
    );
}
impl Default for AllocNode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const RunMode_RunModeRun: RunMode = 0;
pub const RunMode_RunModeSkip: RunMode = 1;
pub const RunMode_RunModeReturn: RunMode = 2;
pub const RunMode_RunModeCaseSearch: RunMode = 3;
pub const RunMode_RunModeBreak: RunMode = 4;
pub const RunMode_RunModeContinue: RunMode = 5;
pub const RunMode_RunModeGoto: RunMode = 6;
pub type RunMode = u32;
#[repr(C)]
#[derive(Debug)]
pub struct ParseState {
    pub pc: *mut Picoc,
    pub Pos: *const ::std::os::raw::c_uchar,
    pub FileName: *mut ::std::os::raw::c_char,
    pub Line: ::std::os::raw::c_short,
    pub CharacterPos: ::std::os::raw::c_short,
    pub Mode: RunMode,
    pub SearchLabel: ::std::os::raw::c_int,
    pub SearchGotoLabel: *const ::std::os::raw::c_char,
    pub SourceText: *const ::std::os::raw::c_char,
    pub HashIfLevel: ::std::os::raw::c_short,
    pub HashIfEvaluateToLevel: ::std::os::raw::c_short,
    pub DebugMode: ::std::os::raw::c_char,
    pub ScopeID: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ParseState() {
    assert_eq!(
        ::std::mem::size_of::<ParseState>(),
        72usize,
        concat!("Size of: ", stringify!(ParseState))
    );
    assert_eq!(
        ::std::mem::align_of::<ParseState>(),
        8usize,
        concat!("Alignment of ", stringify!(ParseState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).pc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).Pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).FileName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).Line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).CharacterPos as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(CharacterPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).Mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).SearchLabel as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(SearchLabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).SearchGotoLabel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(SearchGotoLabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).SourceText as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(SourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).HashIfLevel as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(HashIfLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseState>())).HashIfEvaluateToLevel as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(HashIfEvaluateToLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).DebugMode as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(DebugMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).ScopeID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(ScopeID)
        )
    );
}
impl Default for ParseState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const BaseType_TypeVoid: BaseType = 0;
pub const BaseType_TypeInt: BaseType = 1;
pub const BaseType_TypeShort: BaseType = 2;
pub const BaseType_TypeChar: BaseType = 3;
pub const BaseType_TypeLong: BaseType = 4;
pub const BaseType_TypeUnsignedInt: BaseType = 5;
pub const BaseType_TypeUnsignedShort: BaseType = 6;
pub const BaseType_TypeUnsignedChar: BaseType = 7;
pub const BaseType_TypeUnsignedLong: BaseType = 8;
pub const BaseType_TypeFP: BaseType = 9;
pub const BaseType_TypeFunction: BaseType = 10;
pub const BaseType_TypeMacro: BaseType = 11;
pub const BaseType_TypePointer: BaseType = 12;
pub const BaseType_TypeArray: BaseType = 13;
pub const BaseType_TypeStruct: BaseType = 14;
pub const BaseType_TypeUnion: BaseType = 15;
pub const BaseType_TypeEnum: BaseType = 16;
pub const BaseType_TypeGotoLabel: BaseType = 17;
pub const BaseType_Type_Type: BaseType = 18;
pub type BaseType = u32;
#[repr(C)]
#[derive(Debug)]
pub struct ValueType {
    pub Base: BaseType,
    pub ArraySize: ::std::os::raw::c_int,
    pub Sizeof: ::std::os::raw::c_int,
    pub AlignBytes: ::std::os::raw::c_int,
    pub Identifier: *const ::std::os::raw::c_char,
    pub FromType: *mut ValueType,
    pub DerivedTypeList: *mut ValueType,
    pub Next: *mut ValueType,
    pub Members: *mut Table,
    pub OnHeap: ::std::os::raw::c_int,
    pub StaticQualifier: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ValueType() {
    assert_eq!(
        ::std::mem::size_of::<ValueType>(),
        64usize,
        concat!("Size of: ", stringify!(ValueType))
    );
    assert_eq!(
        ::std::mem::align_of::<ValueType>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).Base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).ArraySize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(ArraySize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).Sizeof as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(Sizeof)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).AlignBytes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(AlignBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).Identifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(Identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).FromType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(FromType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).DerivedTypeList as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(DerivedTypeList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).Next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).Members as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(Members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).OnHeap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(OnHeap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValueType>())).StaticQualifier as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueType),
            "::",
            stringify!(StaticQualifier)
        )
    );
}
impl Default for ValueType {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FuncDef {
    pub ReturnType: *mut ValueType,
    pub NumParams: ::std::os::raw::c_int,
    pub VarArgs: ::std::os::raw::c_int,
    pub ParamType: *mut *mut ValueType,
    pub ParamName: *mut *mut ::std::os::raw::c_char,
    pub Intrinsic: ::std::option::Option<unsafe extern "C" fn()>,
    pub Body: ParseState,
}
#[test]
fn bindgen_test_layout_FuncDef() {
    assert_eq!(
        ::std::mem::size_of::<FuncDef>(),
        112usize,
        concat!("Size of: ", stringify!(FuncDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FuncDef>(),
        8usize,
        concat!("Alignment of ", stringify!(FuncDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).ReturnType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(ReturnType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).NumParams as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(NumParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).VarArgs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(VarArgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).ParamType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(ParamType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).ParamName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(ParamName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).Intrinsic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(Intrinsic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncDef>())).Body as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncDef),
            "::",
            stringify!(Body)
        )
    );
}
impl Default for FuncDef {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct MacroDef {
    pub NumParams: ::std::os::raw::c_int,
    pub ParamName: *mut *mut ::std::os::raw::c_char,
    pub Body: ParseState,
}
#[test]
fn bindgen_test_layout_MacroDef() {
    assert_eq!(
        ::std::mem::size_of::<MacroDef>(),
        88usize,
        concat!("Size of: ", stringify!(MacroDef))
    );
    assert_eq!(
        ::std::mem::align_of::<MacroDef>(),
        8usize,
        concat!("Alignment of ", stringify!(MacroDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MacroDef>())).NumParams as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MacroDef),
            "::",
            stringify!(NumParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MacroDef>())).ParamName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MacroDef),
            "::",
            stringify!(ParamName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MacroDef>())).Body as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MacroDef),
            "::",
            stringify!(Body)
        )
    );
}
impl Default for MacroDef {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct AnyValue {
    pub Character: __BindgenUnionField<::std::os::raw::c_char>,
    pub ShortInteger: __BindgenUnionField<::std::os::raw::c_short>,
    pub Integer: __BindgenUnionField<::std::os::raw::c_int>,
    pub LongInteger: __BindgenUnionField<::std::os::raw::c_long>,
    pub UnsignedShortInteger: __BindgenUnionField<::std::os::raw::c_ushort>,
    pub UnsignedInteger: __BindgenUnionField<::std::os::raw::c_uint>,
    pub UnsignedLongInteger: __BindgenUnionField<::std::os::raw::c_ulong>,
    pub UnsignedCharacter: __BindgenUnionField<::std::os::raw::c_uchar>,
    pub Identifier: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub ArrayMem: __BindgenUnionField<[::std::os::raw::c_char; 2usize]>,
    pub Typ: __BindgenUnionField<*mut ValueType>,
    pub FuncDef: __BindgenUnionField<FuncDef>,
    pub MacroDef: __BindgenUnionField<MacroDef>,
    pub FP: __BindgenUnionField<f64>,
    pub Pointer: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_AnyValue() {
    assert_eq!(
        ::std::mem::size_of::<AnyValue>(),
        112usize,
        concat!("Size of: ", stringify!(AnyValue))
    );
    assert_eq!(
        ::std::mem::align_of::<AnyValue>(),
        8usize,
        concat!("Alignment of ", stringify!(AnyValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).Character as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(Character)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).ShortInteger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(ShortInteger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).Integer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(Integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).LongInteger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(LongInteger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).UnsignedShortInteger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(UnsignedShortInteger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).UnsignedInteger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(UnsignedInteger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).UnsignedLongInteger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(UnsignedLongInteger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).UnsignedCharacter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(UnsignedCharacter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).Identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(Identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).ArrayMem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(ArrayMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).Typ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(Typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).FuncDef as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(FuncDef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).MacroDef as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(MacroDef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).FP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(FP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyValue>())).Pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyValue),
            "::",
            stringify!(Pointer)
        )
    );
}
impl Default for AnyValue {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Value {
    pub Typ: *mut ValueType,
    pub Val: *mut AnyValue,
    pub LValueFrom: *mut Value,
    pub ValOnHeap: ::std::os::raw::c_char,
    pub ValOnStack: ::std::os::raw::c_char,
    pub AnyValOnHeap: ::std::os::raw::c_char,
    pub IsLValue: ::std::os::raw::c_char,
    pub ScopeID: ::std::os::raw::c_int,
    pub OutOfScope: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(
        ::std::mem::size_of::<Value>(),
        40usize,
        concat!("Size of: ", stringify!(Value))
    );
    assert_eq!(
        ::std::mem::align_of::<Value>(),
        8usize,
        concat!("Alignment of ", stringify!(Value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).Typ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(Typ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).Val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(Val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).LValueFrom as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(LValueFrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).ValOnHeap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(ValOnHeap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).ValOnStack as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(ValOnStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).AnyValOnHeap as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(AnyValOnHeap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).IsLValue as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(IsLValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).ScopeID as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(ScopeID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).OutOfScope as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(OutOfScope)
        )
    );
}
impl Default for Value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct TableEntry {
    pub Next: *mut TableEntry,
    pub DeclFileName: *const ::std::os::raw::c_char,
    pub DeclLine: ::std::os::raw::c_ushort,
    pub DeclColumn: ::std::os::raw::c_ushort,
    pub p: TableEntry_TableEntryPayload,
}
#[repr(C)]
pub struct TableEntry_TableEntryPayload {
    pub v: __BindgenUnionField<TableEntry_TableEntryPayload_ValueEntry>,
    pub Key: __BindgenUnionField<[::std::os::raw::c_char; 1usize]>,
    pub b: __BindgenUnionField<TableEntry_TableEntryPayload_BreakpointEntry>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct TableEntry_TableEntryPayload_ValueEntry {
    pub Key: *mut ::std::os::raw::c_char,
    pub Val: *mut Value,
}
#[test]
fn bindgen_test_layout_TableEntry_TableEntryPayload_ValueEntry() {
    assert_eq!(
        ::std::mem::size_of::<TableEntry_TableEntryPayload_ValueEntry>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(TableEntry_TableEntryPayload_ValueEntry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TableEntry_TableEntryPayload_ValueEntry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(TableEntry_TableEntryPayload_ValueEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload_ValueEntry>())).Key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload_ValueEntry),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload_ValueEntry>())).Val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload_ValueEntry),
            "::",
            stringify!(Val)
        )
    );
}
impl Default for TableEntry_TableEntryPayload_ValueEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TableEntry_TableEntryPayload_BreakpointEntry {
    pub FileName: *const ::std::os::raw::c_char,
    pub Line: ::std::os::raw::c_short,
    pub CharacterPos: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_TableEntry_TableEntryPayload_BreakpointEntry() {
    assert_eq!(
        ::std::mem::size_of::<TableEntry_TableEntryPayload_BreakpointEntry>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(TableEntry_TableEntryPayload_BreakpointEntry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TableEntry_TableEntryPayload_BreakpointEntry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(TableEntry_TableEntryPayload_BreakpointEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload_BreakpointEntry>())).FileName
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload_BreakpointEntry),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload_BreakpointEntry>())).Line
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload_BreakpointEntry),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload_BreakpointEntry>())).CharacterPos
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload_BreakpointEntry),
            "::",
            stringify!(CharacterPos)
        )
    );
}
impl Default for TableEntry_TableEntryPayload_BreakpointEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_TableEntry_TableEntryPayload() {
    assert_eq!(
        ::std::mem::size_of::<TableEntry_TableEntryPayload>(),
        16usize,
        concat!("Size of: ", stringify!(TableEntry_TableEntryPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<TableEntry_TableEntryPayload>(),
        8usize,
        concat!("Alignment of ", stringify!(TableEntry_TableEntryPayload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry_TableEntryPayload>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TableEntry_TableEntryPayload>())).Key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry_TableEntryPayload>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry_TableEntryPayload),
            "::",
            stringify!(b)
        )
    );
}
impl Default for TableEntry_TableEntryPayload {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_TableEntry() {
    assert_eq!(
        ::std::mem::size_of::<TableEntry>(),
        40usize,
        concat!("Size of: ", stringify!(TableEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<TableEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(TableEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry>())).Next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry>())).DeclFileName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry),
            "::",
            stringify!(DeclFileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry>())).DeclLine as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry),
            "::",
            stringify!(DeclLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry>())).DeclColumn as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry),
            "::",
            stringify!(DeclColumn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableEntry>())).p as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TableEntry),
            "::",
            stringify!(p)
        )
    );
}
impl Default for TableEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Table {
    pub Size: ::std::os::raw::c_short,
    pub OnHeap: ::std::os::raw::c_short,
    pub HashTable: *mut *mut TableEntry,
}
#[test]
fn bindgen_test_layout_Table() {
    assert_eq!(
        ::std::mem::size_of::<Table>(),
        16usize,
        concat!("Size of: ", stringify!(Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).OnHeap as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(OnHeap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Table>())).HashTable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Table),
            "::",
            stringify!(HashTable)
        )
    );
}
impl Default for Table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct StackFrame {
    pub ReturnParser: ParseState,
    pub FuncName: *const ::std::os::raw::c_char,
    pub ReturnValue: *mut Value,
    pub Parameter: *mut *mut Value,
    pub NumParams: ::std::os::raw::c_int,
    pub LocalTable: Table,
    pub LocalHashTable: [*mut TableEntry; 11usize],
    pub PreviousStackFrame: *mut StackFrame,
}
#[test]
fn bindgen_test_layout_StackFrame() {
    assert_eq!(
        ::std::mem::size_of::<StackFrame>(),
        216usize,
        concat!("Size of: ", stringify!(StackFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<StackFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(StackFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).ReturnParser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(ReturnParser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).FuncName as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(FuncName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).ReturnValue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(ReturnValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).Parameter as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(Parameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).NumParams as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(NumParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).LocalTable as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(LocalTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).LocalHashTable as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(LocalHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StackFrame>())).PreviousStackFrame as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(StackFrame),
            "::",
            stringify!(PreviousStackFrame)
        )
    );
}
impl Default for StackFrame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const LexMode_LexModeNormal: LexMode = 0;
pub const LexMode_LexModeHashInclude: LexMode = 1;
pub const LexMode_LexModeHashDefine: LexMode = 2;
pub const LexMode_LexModeHashDefineSpace: LexMode = 3;
pub const LexMode_LexModeHashDefineSpaceIdent: LexMode = 4;
pub type LexMode = u32;
#[repr(C)]
#[derive(Debug)]
pub struct LexState {
    pub Pos: *const ::std::os::raw::c_char,
    pub End: *const ::std::os::raw::c_char,
    pub FileName: *const ::std::os::raw::c_char,
    pub Line: ::std::os::raw::c_int,
    pub CharacterPos: ::std::os::raw::c_int,
    pub SourceText: *const ::std::os::raw::c_char,
    pub Mode: LexMode,
    pub EmitExtraNewlines: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LexState() {
    assert_eq!(
        ::std::mem::size_of::<LexState>(),
        48usize,
        concat!("Size of: ", stringify!(LexState))
    );
    assert_eq!(
        ::std::mem::align_of::<LexState>(),
        8usize,
        concat!("Alignment of ", stringify!(LexState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).Pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(Pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).End as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(End)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).FileName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).Line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).CharacterPos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(CharacterPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).SourceText as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(SourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).Mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LexState>())).EmitExtraNewlines as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LexState),
            "::",
            stringify!(EmitExtraNewlines)
        )
    );
}
impl Default for LexState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct LibraryFunction {
    pub Func: ::std::option::Option<
        unsafe extern "C" fn(
            Parser: *mut ParseState,
            arg1: *mut Value,
            arg2: *mut *mut Value,
            arg3: ::std::os::raw::c_int,
        ),
    >,
    pub Prototype: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_LibraryFunction() {
    assert_eq!(
        ::std::mem::size_of::<LibraryFunction>(),
        16usize,
        concat!("Size of: ", stringify!(LibraryFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<LibraryFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(LibraryFunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LibraryFunction>())).Func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LibraryFunction),
            "::",
            stringify!(Func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LibraryFunction>())).Prototype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LibraryFunction),
            "::",
            stringify!(Prototype)
        )
    );
}
impl Default for LibraryFunction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct OutputStreamInfo {
    pub Str: __BindgenUnionField<OutputStreamInfo_StringOutputStream>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct OutputStreamInfo_StringOutputStream {
    pub Parser: *mut ParseState,
    pub WritePos: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OutputStreamInfo_StringOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<OutputStreamInfo_StringOutputStream>(),
        16usize,
        concat!("Size of: ", stringify!(OutputStreamInfo_StringOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<OutputStreamInfo_StringOutputStream>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(OutputStreamInfo_StringOutputStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OutputStreamInfo_StringOutputStream>())).Parser as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OutputStreamInfo_StringOutputStream),
            "::",
            stringify!(Parser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OutputStreamInfo_StringOutputStream>())).WritePos as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OutputStreamInfo_StringOutputStream),
            "::",
            stringify!(WritePos)
        )
    );
}
impl Default for OutputStreamInfo_StringOutputStream {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_OutputStreamInfo() {
    assert_eq!(
        ::std::mem::size_of::<OutputStreamInfo>(),
        16usize,
        concat!("Size of: ", stringify!(OutputStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OutputStreamInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OutputStreamInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OutputStreamInfo>())).Str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OutputStreamInfo),
            "::",
            stringify!(Str)
        )
    );
}
impl Default for OutputStreamInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CharWriter = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_uchar, arg2: *mut OutputStreamInfo),
>;
#[repr(C)]
pub struct OutputStream {
    pub Putch: CharWriter,
    pub i: OutputStreamInfo,
}
#[test]
fn bindgen_test_layout_OutputStream() {
    assert_eq!(
        ::std::mem::size_of::<OutputStream>(),
        24usize,
        concat!("Size of: ", stringify!(OutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<OutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(OutputStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OutputStream>())).Putch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OutputStream),
            "::",
            stringify!(Putch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OutputStream>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OutputStream),
            "::",
            stringify!(i)
        )
    );
}
impl Default for OutputStream {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const ParseResult_ParseResultEOF: ParseResult = 0;
pub const ParseResult_ParseResultError: ParseResult = 1;
pub const ParseResult_ParseResultOk: ParseResult = 2;
pub type ParseResult = u32;
#[repr(C)]
#[derive(Debug)]
pub struct CleanupTokenNode {
    pub Tokens: *mut ::std::os::raw::c_void,
    pub SourceText: *const ::std::os::raw::c_char,
    pub Next: *mut CleanupTokenNode,
}
#[test]
fn bindgen_test_layout_CleanupTokenNode() {
    assert_eq!(
        ::std::mem::size_of::<CleanupTokenNode>(),
        24usize,
        concat!("Size of: ", stringify!(CleanupTokenNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CleanupTokenNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CleanupTokenNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CleanupTokenNode>())).Tokens as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CleanupTokenNode),
            "::",
            stringify!(Tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CleanupTokenNode>())).SourceText as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CleanupTokenNode),
            "::",
            stringify!(SourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CleanupTokenNode>())).Next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CleanupTokenNode),
            "::",
            stringify!(Next)
        )
    );
}
impl Default for CleanupTokenNode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TokenLine {
    pub Next: *mut TokenLine,
    pub Tokens: *mut ::std::os::raw::c_uchar,
    pub NumBytes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TokenLine() {
    assert_eq!(
        ::std::mem::size_of::<TokenLine>(),
        24usize,
        concat!("Size of: ", stringify!(TokenLine))
    );
    assert_eq!(
        ::std::mem::align_of::<TokenLine>(),
        8usize,
        concat!("Alignment of ", stringify!(TokenLine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TokenLine>())).Next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TokenLine),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TokenLine>())).Tokens as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TokenLine),
            "::",
            stringify!(Tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TokenLine>())).NumBytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TokenLine),
            "::",
            stringify!(NumBytes)
        )
    );
}
impl Default for TokenLine {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct IncludeLibrary {
    pub IncludeName: *mut ::std::os::raw::c_char,
    pub SetupFunction: ::std::option::Option<unsafe extern "C" fn(pc: *mut Picoc)>,
    pub FuncList: *mut LibraryFunction,
    pub SetupCSource: *const ::std::os::raw::c_char,
    pub NextLib: *mut IncludeLibrary,
}
#[test]
fn bindgen_test_layout_IncludeLibrary() {
    assert_eq!(
        ::std::mem::size_of::<IncludeLibrary>(),
        40usize,
        concat!("Size of: ", stringify!(IncludeLibrary))
    );
    assert_eq!(
        ::std::mem::align_of::<IncludeLibrary>(),
        8usize,
        concat!("Alignment of ", stringify!(IncludeLibrary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IncludeLibrary>())).IncludeName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IncludeLibrary),
            "::",
            stringify!(IncludeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IncludeLibrary>())).SetupFunction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IncludeLibrary),
            "::",
            stringify!(SetupFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IncludeLibrary>())).FuncList as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IncludeLibrary),
            "::",
            stringify!(FuncList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IncludeLibrary>())).SetupCSource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IncludeLibrary),
            "::",
            stringify!(SetupCSource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IncludeLibrary>())).NextLib as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IncludeLibrary),
            "::",
            stringify!(NextLib)
        )
    );
}
impl Default for IncludeLibrary {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct Picoc_Struct {
    pub GlobalTable: Table,
    pub CleanupTokenList: *mut CleanupTokenNode,
    pub GlobalHashTable: [*mut TableEntry; 97usize],
    pub InteractiveHead: *mut TokenLine,
    pub InteractiveTail: *mut TokenLine,
    pub InteractiveCurrentLine: *mut TokenLine,
    pub LexUseStatementPrompt: ::std::os::raw::c_int,
    pub LexAnyValue: AnyValue,
    pub LexValue: Value,
    pub ReservedWordTable: Table,
    pub ReservedWordHashTable: [*mut TableEntry; 97usize],
    pub StringLiteralTable: Table,
    pub StringLiteralHashTable: [*mut TableEntry; 97usize],
    pub TopStackFrame: *mut StackFrame,
    pub PicocExitValue: ::std::os::raw::c_int,
    pub IncludeLibList: *mut IncludeLibrary,
    pub HeapMemory: *mut ::std::os::raw::c_uchar,
    pub HeapBottom: *mut ::std::os::raw::c_void,
    pub StackFrame: *mut ::std::os::raw::c_void,
    pub HeapStackTop: *mut ::std::os::raw::c_void,
    pub FreeListBucket: [*mut AllocNode; 8usize],
    pub FreeListBig: *mut AllocNode,
    pub UberType: ValueType,
    pub IntType: ValueType,
    pub ShortType: ValueType,
    pub CharType: ValueType,
    pub LongType: ValueType,
    pub UnsignedIntType: ValueType,
    pub UnsignedShortType: ValueType,
    pub UnsignedLongType: ValueType,
    pub UnsignedCharType: ValueType,
    pub FPType: ValueType,
    pub VoidType: ValueType,
    pub TypeType: ValueType,
    pub FunctionType: ValueType,
    pub MacroType: ValueType,
    pub EnumType: ValueType,
    pub GotoLabelType: ValueType,
    pub CharPtrType: *mut ValueType,
    pub CharPtrPtrType: *mut ValueType,
    pub CharArrayType: *mut ValueType,
    pub VoidPtrType: *mut ValueType,
    pub BreakpointTable: Table,
    pub BreakpointHashTable: [*mut TableEntry; 21usize],
    pub BreakpointCount: ::std::os::raw::c_int,
    pub DebugManualBreak: ::std::os::raw::c_int,
    pub BigEndian: ::std::os::raw::c_int,
    pub LittleEndian: ::std::os::raw::c_int,
    pub CStdOut: *mut IOFILE,
    pub CStdOutBase: IOFILE,
    pub VersionString: *const ::std::os::raw::c_char,
    pub PicocExitBuf: jmp_buf,
    pub StringTable: Table,
    pub StringHashTable: [*mut TableEntry; 97usize],
    pub StrEmpty: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Picoc_Struct() {
    assert_eq!(
        ::std::mem::size_of::<Picoc_Struct>(),
        5184usize,
        concat!("Size of: ", stringify!(Picoc_Struct))
    );
    assert_eq!(
        ::std::mem::align_of::<Picoc_Struct>(),
        8usize,
        concat!("Alignment of ", stringify!(Picoc_Struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).GlobalTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(GlobalTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CleanupTokenList as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CleanupTokenList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).GlobalHashTable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(GlobalHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).InteractiveHead as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(InteractiveHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).InteractiveTail as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(InteractiveTail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Picoc_Struct>())).InteractiveCurrentLine as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(InteractiveCurrentLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Picoc_Struct>())).LexUseStatementPrompt as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(LexUseStatementPrompt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).LexAnyValue as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(LexAnyValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).LexValue as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(LexValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).ReservedWordTable as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(ReservedWordTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Picoc_Struct>())).ReservedWordHashTable as *const _ as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(ReservedWordHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).StringLiteralTable as *const _ as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StringLiteralTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Picoc_Struct>())).StringLiteralHashTable as *const _ as usize
        },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StringLiteralHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).TopStackFrame as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(TopStackFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).PicocExitValue as *const _ as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(PicocExitValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).IncludeLibList as *const _ as usize },
        2584usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(IncludeLibList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).HeapMemory as *const _ as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(HeapMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).HeapBottom as *const _ as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(HeapBottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).StackFrame as *const _ as usize },
        2608usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StackFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).HeapStackTop as *const _ as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(HeapStackTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).FreeListBucket as *const _ as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(FreeListBucket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).FreeListBig as *const _ as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(FreeListBig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).UberType as *const _ as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(UberType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).IntType as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(IntType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).ShortType as *const _ as usize },
        2824usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(ShortType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CharType as *const _ as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CharType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).LongType as *const _ as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(LongType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).UnsignedIntType as *const _ as usize },
        3016usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(UnsignedIntType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).UnsignedShortType as *const _ as usize },
        3080usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(UnsignedShortType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).UnsignedLongType as *const _ as usize },
        3144usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(UnsignedLongType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).UnsignedCharType as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(UnsignedCharType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).FPType as *const _ as usize },
        3272usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(FPType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).VoidType as *const _ as usize },
        3336usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(VoidType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).TypeType as *const _ as usize },
        3400usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(TypeType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).FunctionType as *const _ as usize },
        3464usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(FunctionType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).MacroType as *const _ as usize },
        3528usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(MacroType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).EnumType as *const _ as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(EnumType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).GotoLabelType as *const _ as usize },
        3656usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(GotoLabelType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CharPtrType as *const _ as usize },
        3720usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CharPtrType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CharPtrPtrType as *const _ as usize },
        3728usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CharPtrPtrType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CharArrayType as *const _ as usize },
        3736usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CharArrayType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).VoidPtrType as *const _ as usize },
        3744usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(VoidPtrType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).BreakpointTable as *const _ as usize },
        3752usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(BreakpointTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Picoc_Struct>())).BreakpointHashTable as *const _ as usize
        },
        3768usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(BreakpointHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).BreakpointCount as *const _ as usize },
        3936usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(BreakpointCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).DebugManualBreak as *const _ as usize },
        3940usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(DebugManualBreak)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).BigEndian as *const _ as usize },
        3944usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(BigEndian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).LittleEndian as *const _ as usize },
        3948usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(LittleEndian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CStdOut as *const _ as usize },
        3952usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CStdOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).CStdOutBase as *const _ as usize },
        3960usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(CStdOutBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).VersionString as *const _ as usize },
        4176usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(VersionString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).PicocExitBuf as *const _ as usize },
        4184usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(PicocExitBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).StringTable as *const _ as usize },
        4384usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StringTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).StringHashTable as *const _ as usize },
        4400usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StringHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Picoc_Struct>())).StrEmpty as *const _ as usize },
        5176usize,
        concat!(
            "Offset of field: ",
            stringify!(Picoc_Struct),
            "::",
            stringify!(StrEmpty)
        )
    );
}
impl Default for Picoc_Struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn PicocExecute(
        pc: *mut Picoc,
        FileName: *const ::std::os::raw::c_char,
        Source: *const ::std::os::raw::c_char,
        SourceLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PicocInitialise(pc: *mut Picoc, StackSize: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PicocCleanup(pc: *mut Picoc);
}
extern "C" {
    pub fn PicocIncludeAllSystemHeaders(pc: *mut Picoc);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
